#!/usr/bin/env python3
"""
regview
"""

import argparse
import re
import sys

from collections import OrderedDict
from concurrent.futures import ThreadPoolExecutor
from getpass import getpass
from shutil import get_terminal_size

from _regview.docker_registry import DockerRegistry
from _regview.utils import pretty_date, pretty_size, is_glob
from _regview import __version__


class DockerRegistryInfo(DockerRegistry):
    """
    Subclass of DockerRegistry
    """
    def get_info(self, repo, tag, fat=False):
        """
        Get info from manifest v2
        """
        manifest = None
        if fat:
            content_type = 'application/vnd.docker.distribution.manifest.list.v2+json'
            manifest = self.get_manifest(repo, tag, fat=True)
            if manifest and manifest.get('mediaType') == content_type:
                infos = []
                for item in manifest['manifests']:
                    info = self.get_info(repo, item['digest'])
                    if not info:
                        continue
                    keys = ('architecture', 'os', 'variant')
                    info.update({k: item['platform'][k] for k in keys if k in item['platform']})
                    keys = ('features', 'os.features')
                    info.update({k: ",".join(info[k]) for k in keys if k in info})
                    infos.append(info)
                return infos
        if not manifest:
            manifest = self.get_manifest(repo, tag)
        if not manifest:
            return None
        info = {
            'Digest': tag if tag.startswith("sha256:") else manifest['docker-content-digest'],
            'CompressedSize': sum([_['size'] for _ in manifest['layers']]),
            'ID': manifest['config']['digest']}
        return info

    def print_fat(self, repo, tag="latest"):
        """
        Print fat manifest
        """
        infos = self.get_info(repo, tag, fat=True)
        if not isinstance(infos, list):
            self.print_fullinfo(repo, tag)
            return
        for info in infos:
            for key, value in sorted(info.items()):
                print(f"{key:<20}\t{value}")
            print()

    def print_fullinfo(self, repo, tag="latest"):
        """
        Print full info about image
        """
        info = self.get_info(repo, tag)
        if info is None:
            return
        info.update(self.get_blob(repo, info['ID']).json())
        if not opts.raw:
            info['created'] = pretty_date(info['created'])
            info['CompressedSize'] = pretty_size(info['CompressedSize'])
        keys = (
            'architecture', 'author', 'created', 'docker_version', 'os',
            'CompressedSize', 'ID', 'Digest')
        data = {key: info[key] for key in keys if info.get(key)}
        keys = (
            'Cmd', 'Entrypoint', 'Env', 'ExposedPorts',
            'Healthcheck', 'Labels', 'OnBuild', 'Shell',
            'StopSignal', 'User', 'Volumes', 'WorkingDir')
        if opts.verbose:
            data.update({key: info['config'][key] for key in keys if info['config'].get(key)})
        for key in sorted(data, key=str.casefold):
            print(f"{key:<20}\t{data[key]}")
        if opts.verbose:
            self.print_history(info['history'])

    @staticmethod
    def print_history(history):
        """
        Print image history
        """
        for i, item in enumerate(history):
            print(f"History[{i}]\t\t{item['created_by']}")

    @staticmethod
    def print_info(repo, tag, info, fmt):
        """
        Print info about image
        """
        docker_id = info['ID']
        if not opts.no_trunc:
            docker_id = docker_id[len("sha256:"):len("sha256:") + 12]
        values = [f"{repo}:{tag}", docker_id]
        if opts.digests:
            values.insert(1, info['Digest'])
        if opts.verbose:
            created = info['created']
            if not opts.raw:
                created = pretty_date(created)
            values.append(created)
        if opts.all:
            values.append(info.get('os', "-"))
            values.append(info.get('architecture', "-"))
        print(fmt % tuple(values))

    def get_images(self, repos, pattern_tag=None):
        """
        Get images"
        """
        with ThreadPoolExecutor(max_workers=2) as executor:
            yield from executor.map(lambda r: (r, self.get_tags(r, pattern_tag)), repos)

    def print_all(self, repo_pattern, tag_pattern):
        """
        Print all
        """
        # Do not try to get the catalog when globbing only the tag
        repos = self.get_repos(repo_pattern) if is_glob(repo_pattern) or repo_pattern is None \
            else [repo_pattern]
        if not repos:
            return
        image_width = min(
            int(get_terminal_size().columns / 2),
            max(len(repo) for repo in repos) + 20)
        fmt = OrderedDict({
            "REPOSITORY:TAG": f"%-{image_width}s",
            "IMAGE ID": "%-72s" if opts.no_trunc else "%-12s",
            "DIGEST": "%-72s" if opts.digests else None,
            "CREATED ON": "%-31s" if opts.verbose else None,
            "OS": "%-8s" if opts.all else None,
            "ARCH": "%s" if opts.all else None})
        fmt = {k: fmt[k] for k in fmt if fmt[k]}
        keys = fmt.keys()
        fmt = "  ".join(fmt.values())
        print(fmt % tuple(keys))
        with ThreadPoolExecutor() as executor:
            for repo, tags in self.get_images(repos, tag_pattern):
                if tags is None:
                    continue
                infos = executor.map(lambda t, r=repo: self.get_info(r, t, fat=opts.all), tags)
                for tag, info in zip(tags, infos):
                    if not isinstance(info, list):
                        info = [info]
                    for info_ in info:
                        if info_ is None:
                            continue
                        if opts.verbose:
                            info_.update(self.get_blob(repo, info_['ID']).json())
                        self.print_info(repo, tag, info_, fmt)


def parse_opts():
    """
    Parse options and arguments
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-a', '--all', action='store_true',
        help="Print information for all architectures")
    parser.add_argument(
        '-c', '--cert',
        help="Client certificate filename (may contain unencrypted key)")
    parser.add_argument(
        '-k', '--key',
        help="Client private key filename (unencrypted)")
    parser.add_argument(
        '-C', '--cacert',
        help="CA certificate for server")
    parser.add_argument(
        '--debug', action='store_true',
        help="Enable debug")
    parser.add_argument(
        '--digests', action='store_true',
        help="Show digests")
    parser.add_argument(
        '--insecure', action='store_true',
        help="Allow insecure server connections")
    parser.add_argument(
        '--no-trunc', action='store_true',
        help="Don't truncate output")
    parser.add_argument(
        '--raw', action='store_true',
        help="Raw values for date and size")
    parser.add_argument(
        '-u', '--username',
        help="Username for authentication")
    parser.add_argument(
        '-p', '--password',
        help="Password for authentication")
    parser.add_argument(
        '-v', '--verbose', action='store_true',
        help="Show more information")
    parser.add_argument(
        '-V', '--version', action='store_true',
        help="Show version and exit")
    parser.add_argument('image', nargs='?', help="REGISTRY[/REPOSITORY[:TAG|@DIGEST]]")
    return parser.parse_args()


def main():
    """
    Main function
    """
    if opts.version:
        print(__version__)
        sys.exit(0)
    if not opts.image:
        print(f"Usage: {sys.argv[0]} [OPTIONS] REGISTRY[/REPOSITORY[:TAG|@DIGEST]]")
        sys.exit(1)
    if opts.username and not opts.password:
        opts.password = getpass("Password: ")
    match = re.match(r'((?:https?://)?[^:/]+(?::[0-9]+)?)/*(.*)', opts.image)
    registry, image = match.group(1), match.group(2)
    pattern_repo = pattern_tag = None
    if '@' not in image and is_glob(image):
        pattern_repo, pattern_tag = image.split(':', 1) if ':' in image else (image, None)
    with DockerRegistryInfo(
            registry,
            auth=(opts.username, opts.password) if opts.username else None,
            cert=(opts.cert, opts.key) if opts.cert and opts.key else opts.cert,
            headers={'User-Agent': f"regview/{__version__}"},
            verify=opts.cacert if opts.cacert else not opts.insecure,
            debug=opts.debug) as reg:
        if image and not pattern_repo:
            sep = '@' if '@' in image else ':'
            if opts.all and sep != '@':
                reg.print_fat(*image.split(sep, 1))
            else:
                reg.print_fullinfo(*image.split(sep, 1))
            return
        reg.print_all(pattern_repo, pattern_tag)


if __name__ == "__main__":
    try:
        opts = parse_opts()
        main()
    except KeyboardInterrupt:
        sys.exit(1)
