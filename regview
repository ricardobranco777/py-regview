#!/usr/bin/env python3
"""
regview
"""

import argparse
import re
import sys

from collections import OrderedDict
from concurrent.futures import ThreadPoolExecutor
from functools import lru_cache
from getpass import getpass
from shutil import get_terminal_size

from _regview.docker_registry import DockerRegistry
from _regview.utils import pretty_date, pretty_size, is_glob
from _regview import __version__


class DockerRegistryInfo(DockerRegistry):
    """
    Subclass of DockerRegistry
    """

    @lru_cache(maxsize=128)
    def get_info_digest(self, repo, digest):
        """
        Cached version of get_info() for digests
        """
        return self.get_info(repo, digest)

    def get_info(self, repo, tag):
        """
        Get info from manifest v2
        """
        content_type_fat = 'application/vnd.docker.distribution.manifest.list.v2+json'
        manifest = self.get_manifest(repo, tag, fat=True)
        if not manifest:
            manifest = self.get_manifest(repo, tag)
            if not manifest:
                return None
        if manifest and manifest.get('mediaType') == content_type_fat:
            infos = []
            for item in manifest['manifests']:
                if opts.arch and item['platform']['architecture'] not in opts.arch or \
                        opts.os and item['platform']['os'] not in opts.os:
                    continue
                info = self.get_info_digest(repo, item['digest'])
                if not info:
                    continue
                # Fix digest for multi-arch
                info['Digest'] = manifest['docker-content-digest']
                if not opts.all:
                    return info
                keys = ('architecture', 'os', 'variant')
                info.update({k: item['platform'][k] for k in keys if k in item['platform']})
                keys = ('features', 'os.features')
                info.update({k: ",".join(info[k]) for k in keys if k in info})
                infos.append(info)
            return infos
        info = {
            'Digest': tag if tag.startswith("sha256:") else manifest['docker-content-digest'],
            'CompressedSize': sum([_['size'] for _ in manifest['layers']]),
            'ID': manifest['config']['digest']}
        return info

    def print_fullinfo(self, repo, tag="latest"):
        """
        Print full info about image
        """
        infos = self.get_info(repo, tag)
        if infos is None:
            return
        if isinstance(infos, list):
            for info in infos:
                for key, value in sorted(info.items()):
                    print(f"{key:<20}\t{value}")
                print()
            return
        info = infos
        info.update(self.get_blob(repo, info['ID']).json())
        if not opts.raw:
            info['created'] = pretty_date(info['created'])
            info['CompressedSize'] = pretty_size(info['CompressedSize'])
        keys = (
            'architecture', 'author', 'created', 'docker_version', 'os',
            'CompressedSize', 'ID', 'Digest')
        data = {key: info[key] for key in keys if info.get(key)}
        keys = (
            'Cmd', 'Entrypoint', 'Env', 'ExposedPorts',
            'Healthcheck', 'Labels', 'OnBuild', 'Shell',
            'StopSignal', 'User', 'Volumes', 'WorkingDir')
        if opts.verbose:
            data.update({key: info['config'][key] for key in keys if info['config'].get(key)})
        for key in sorted(data, key=str.casefold):
            print(f"{key:<20}\t{data[key]}")
        if opts.verbose:
            self.print_history(info['history'])

    @staticmethod
    def print_history(history):
        """
        Print image history
        """
        for i, item in enumerate(history):
            print(f"History[{i}]\t\t{item['created_by']}")

    @staticmethod
    def print_info(repo, tag, info, fmt):
        """
        Print info about image
        """
        docker_id = info['ID']
        if not opts.no_trunc:
            docker_id = docker_id[len("sha256:"):len("sha256:") + 12]
        values = [f"{repo}:{tag}", docker_id]
        if opts.digests:
            values.insert(1, info['Digest'])
        if opts.verbose:
            created = info['created']
            if not opts.raw:
                created = pretty_date(created)
            values.append(created)
        if opts.all:
            values.append(info['os'])
            values.append(info['architecture'])
        print(fmt % tuple(values))

    def get_images(self, repos, pattern_tag=None):
        """
        Get images"
        """
        with ThreadPoolExecutor(max_workers=2) as executor:
            yield from executor.map(lambda r: (r, self.get_tags(r, pattern_tag)), repos)

    def print_all(self, repo_pattern, tag_pattern):
        """
        Print all
        """
        # Do not try to get the catalog when globbing only the tag
        repos = self.get_repos(repo_pattern) if is_glob(repo_pattern) or repo_pattern is None \
            else [repo_pattern]
        if not repos:
            return
        image_width = min(
            int(get_terminal_size().columns / 2),
            max(len(repo) for repo in repos) + 20)
        fmt = OrderedDict({
            "REPOSITORY:TAG": f"%-{image_width}s",
            "DIGEST": "%-72s" if opts.digests else None,
            "IMAGE ID": "%-72s" if opts.no_trunc else "%-12s",
            "CREATED ON": "%-31s" if opts.verbose else None,
            "OS": "%-8s" if opts.all else None,
            "ARCH": "%s" if opts.all else None})
        fmt = {k: fmt[k] for k in fmt if fmt[k]}
        keys = fmt.keys()
        fmt = "  ".join(fmt.values())
        print(fmt % tuple(keys))
        with ThreadPoolExecutor() as executor:
            for repo, tags in self.get_images(repos, tag_pattern):
                if tags is None:
                    continue
                infox = executor.map(lambda t, r=repo: self.get_info(r, t), tags)
                for tag, infos in zip(tags, infox):
                    if not isinstance(infos, list):
                        infos = [infos]
                    for info in infos:
                        if info is None:
                            continue
                        if opts.all or opts.verbose:
                            info.update(self.get_blob(repo, info['ID']).json())
                            if opts.arch and info['architecture'] not in opts.arch or \
                                    opts.os and info['os'] not in opts.os:
                                continue
                        self.print_info(repo, tag, info, fmt)


def parse_opts():
    """
    Parse options and arguments
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-a', '--all', action='store_true',
        help="Print information for all architectures")
    parser.add_argument(
        '--arch', action='append',
        choices=['386', 'amd64', 'arm', 'arm64', 'mips', 'mips64', 'mips64le',
                 'mipsle', 'ppc64', 'ppc64le', 'riscv64', 's390x', 'wasm'],
        help="Target architecture.  May be specified multiple times")
    parser.add_argument(
        '--os', action='append',
        choices=['aix', 'android', 'darwin', 'dragonfly', 'freebsd', 'illumos', 'ios',
                 'js', 'linux', 'netbsd', 'openbsd', 'plan9', 'solaris', 'windows'],
        help="Target OS.  May be specified multiple times")
    parser.add_argument(
        '-c', '--cert',
        help="Client certificate filename (may contain unencrypted key)")
    parser.add_argument(
        '-k', '--key',
        help="Client private key filename (unencrypted)")
    parser.add_argument(
        '-C', '--cacert',
        help="CA certificate for server")
    parser.add_argument(
        '--debug', action='store_true',
        help="Enable debug")
    parser.add_argument(
        '--digests', action='store_true',
        help="Show digests")
    parser.add_argument(
        '--insecure', action='store_true',
        help="Allow insecure server connections")
    parser.add_argument(
        '--no-trunc', action='store_true',
        help="Don't truncate output")
    parser.add_argument(
        '--raw', action='store_true',
        help="Raw values for date and size")
    parser.add_argument(
        '-u', '--username',
        help="Username for authentication")
    parser.add_argument(
        '-p', '--password',
        help="Password for authentication")
    parser.add_argument(
        '-v', '--verbose', action='store_true',
        help="Show more information")
    parser.add_argument(
        '-V', '--version', action='store_true',
        help="Show version and exit")
    parser.add_argument('image', nargs='?', help="REGISTRY[/REPOSITORY[:TAG|@DIGEST]]")
    return parser.parse_args()


def main():
    """
    Main function
    """
    if opts.version:
        print(__version__)
        sys.exit(0)
    if not opts.image:
        print(f"Usage: {sys.argv[0]} [OPTIONS] REGISTRY[/REPOSITORY[:TAG|@DIGEST]]")
        sys.exit(1)
    if opts.username and not opts.password:
        opts.password = getpass("Password: ")
    if opts.arch or opts.os:
        opts.arch, opts.os = set(opts.arch if opts.arch else []), set(opts.os if opts.os else [])
        opts.all = True
    match = re.match(r'((?:https?://)?[^:/]+(?::[0-9]+)?)/*(.*)', opts.image)
    registry, image = match.group(1), match.group(2)
    pattern_repo = pattern_tag = None
    if '@' not in image and is_glob(image):
        pattern_repo, pattern_tag = image.split(':', 1) if ':' in image else (image, None)
    with DockerRegistryInfo(
            registry,
            auth=(opts.username, opts.password) if opts.username else None,
            cert=(opts.cert, opts.key) if opts.cert and opts.key else opts.cert,
            headers={'User-Agent': f"regview/{__version__}"},
            verify=opts.cacert if opts.cacert else not opts.insecure,
            debug=opts.debug) as reg:
        if image and not pattern_repo:
            sep = '@' if '@' in image else ':'
            reg.print_fullinfo(*image.split(sep, 1))
            return
        reg.print_all(pattern_repo, pattern_tag)


if __name__ == "__main__":
    try:
        opts = parse_opts()
        main()
    except KeyboardInterrupt:
        sys.exit(1)
