#!/usr/bin/env python3
"""
regview
"""

import argparse
import base64
import fnmatch
import json
import logging
import os
import re
import sys

from concurrent.futures import ThreadPoolExecutor
from getpass import getpass
from shutil import get_terminal_size

import dateutil.parser
import requests
from requests.exceptions import RequestException
from requests_toolbelt.utils import dump
from urllib3 import disable_warnings


__version__ = "0.1.0a"


class DockerRegistry:
    """
    Class to implement Docker Registry methods
    """
    def __init__(self, registry, auth=None, cert=None, headers=None, verify=True, debug=False):  # pylint: disable=too-many-arguments
        self.session = requests.Session()
        logging.basicConfig(format='%(levelname)s: %(message)s')
        if debug:
            self._enable_debug()
        if not auth:
            auth = self._get_creds(registry)
        elif len(auth) < 2:
            auth = (auth[0], getpass("Password: "))
        self.session.auth = auth
        self.session.cert = cert
        if headers:
            self.session.headers.update(headers)
        self.session.verify = verify
        # Check if registry starts with a scheme and adjust accordingly
        if registry.startswith(("http://", "https://")):
            try:
                got = self.session.get(f"{registry}/v2/")
            except RequestException as err:
                logging.error("%s", err)
                sys.exit(1)
            self.registry = registry
        else:
            try:
                got = self.session.get(f"https://{registry}/v2/")
                self.registry = f"https://{registry}"
            except RequestException:
                try:
                    got = self.session.get(f"http://{registry}/v2/")
                    self.registry = f"http://{registry}"
                except RequestException as err:
                    logging.error("%s", err)
                    sys.exit(1)
        if got.headers.get('docker-distribution-api-version') != 'registry/2.0':
            logging.error("Invalid registry: %s", registry)
            sys.exit(1)
        disable_warnings()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.session.close()

    def _enable_debug(self):
        logging.getLogger().setLevel(logging.DEBUG)
        requests_log = logging.getLogger("urllib3")
        requests_log.setLevel(logging.DEBUG)
        requests_log.propagate = True
        self.session.hooks['response'].append(self._print_response)

    @staticmethod
    def _get_creds(registry):
        """
        Gets the credentials from ~/.docker/config.json
        """
        config_file = os.path.join(
            os.getenv("DOCKER_CONFIG", os.path.expanduser(os.path.join("~", ".docker"))),
            "config.json")
        try:
            with open(config_file) as file:
                config = json.load(file)
        except OSError:
            return None
        registry = re.sub("^https?://", "", registry)
        for try_registry in (f"https://{registry}", f"http://{registry}", registry):
            try:
                auth = config['auths'][try_registry]['auth']
                return tuple(base64.b64decode(auth).decode('utf-8').split(':', 1))
            except KeyError:
                pass
        return None

    @staticmethod
    def _print_response(got, *args, **kwargs):  # pylint: disable=unused-argument
        """
        Print response to aid in debugging
        """
        got.hook_called = True
        data = dump.dump_all(got)
        print(data.decode('utf-8'))
        return got

    def _get_paginated(self, url, string):
        """
        Get paginated results
        """
        items = []
        while True:
            got = self.session.get(url)
            if got.status_code != requests.codes.OK:  # pylint: disable=no-member
                logging.error("%s: %s", url, got.reason)
                return None
            items.extend(got.json()[string])
            if 'Link' in got.headers:
                url = requests.utils.parse_header_links(got.headers['Link'])[0]['url']
                if url.startswith("/v2/"):
                    url = f"{self.registry}{url}"
            else:
                break
        return items

    def get_repos(self, pattern=None):
        """
        Get repositories and return a dict of dicts with the repos as keys
        """
        repos = self._get_paginated(f"{self.registry}/v2/_catalog", "repositories")
        if repos and pattern:
            return fnmatch.filter(repos, pattern)
        return repos

    def get_tags(self, repo, pattern):
        """
        Get tags for specified repo
        """
        tags = self._get_paginated(f"{self.registry}/v2/{repo}/tags/list", "tags")
        if tags and pattern:
            tags = fnmatch.filter(tags, pattern)
        return repo, tags

    def get_manifest(self, repo, tag, fat=False):
        """
        Get the manifest
        """
        url = f"{self.registry}/v2/{repo}/manifests/{tag}"
        content_type = "application/vnd.docker.distribution.manifest.v2+json"
        if fat:
            content_type = "application/vnd.docker.distribution.manifest.list.v2+json"
        got = self.session.get(url, headers={"Accept": content_type})
        if got.status_code != requests.codes.OK:  # pylint: disable=no-member
            fmt = "%s@%s: %s" if tag.startswith("sha256:") else "%s:%s:%s"
            logging.error(fmt, repo, tag, got.reason)
            return None
        manifest = got.json()
        if got.headers['content-type'] == "application/vnd.docker.distribution.manifest.v2+json":
            manifest['docker-content-digest'] = got.headers['docker-content-digest']
        return manifest

    def get_blob(self, repo, digest):
        """
        Get blob
        """
        got = self.session.get(f"{self.registry}/v2/{repo}/blobs/{digest}")
        if got.status_code != requests.codes.OK:  # pylint: disable=no-member
            logging.error("%s@%s", repo, digest)
            return None
        return got


def get_info(reg, repo, tag):
    """
    Get info from manifest v2 and digest blob
    """
    manifest = reg.get_manifest(repo, tag)
    if not manifest:
        return None
    info = {
        'CompressedSize': sum([_['size'] for _ in manifest['layers']]),
        'Digest': manifest['docker-content-digest'],
        'ID': manifest['config']['digest']}
    if opts.verbose:
        blob = reg.get_blob(repo, manifest['config']['digest'])
        info.update(blob.json())
    return info


def get_infox(manifest):
    """
    Get info from manifest schemaVersion 1
    """
    data = json.loads(manifest['history'][0]['v1Compatibility'])
    keys = ('architecture', 'created', 'docker_version', 'os')
    info = {key: data[key] for key in keys if data.get(key)}
    keys = (
        'Cmd', 'Entrypoint', 'Env', 'ExposedPorts',
        'Healthcheck', 'Labels', 'OnBuild', 'Shell',
        'StopSignal', 'User', 'Volumes', 'WorkingDir'
    )
    info.update({key: data['config'][key] for key in keys if data['config'].get(key)})
    return info


def pretty_size(size):
    """
    Converts a size in bytes to a string in KB, MB, GB or TB
    """
    units = (' ', 'K', 'M', 'G', 'T')
    for i in range(4, -1, -1):
        if size > 1024**i:
            return "%.2f%cB" % (float(size) / 1024**i, units[i])
    return None


def pretty_date(string):
    """
    Converts date/time string in ISO-8601 format to date(1)
    """
    # utc_date = datetime.fromisoformat(re.sub(r"\.\d+Z$", "+00:00", string))  # Python 3.7+ only
    utc_date = dateutil.parser.isoparse(string).replace(tzinfo=None)
    return utc_date.astimezone().strftime("%a %b %d %H:%M:%S %Z %Y")


def print_fat_manifest(reg, repo, fat_manifest):
    """
    Print fat manifest
    """
    for item in fat_manifest['manifests']:
        manifest = reg.get_manifest(repo, item['digest'])
        if not manifest:
            sys.exit(1)
        info = {}
        info['ID'] = item['digest']
        info['Digest'] = manifest['config']['digest']
        info['CompressedSize'] = pretty_size(sum([_['size'] for _ in manifest['layers']]))
        keys = ('architecture', 'os', 'variant')
        info.update({key: item['platform'][key] for key in keys if key in item['platform']})
        keys = ('features', 'os.features')
        info.update({key: ",".join(info[key]) for key in keys if key in info})
        for key, value in sorted(info.items()):
            print("%-20s\t%s" % (key, value))
        print()


def print_fullinfo(reg, repo, tag="latest"):
    """
    Print full info about image
    """
    info = get_info(reg, repo, tag)
    if info is None:
        return
    if 'created' in info:
        info['created'] = pretty_date(info['created'])
    info['CompressedSize'] = pretty_size(info['CompressedSize'])
    keys = (
        'architecture', 'created', 'docker_version', 'os',
        'CompressedSize', 'ID', 'Digest')
    data = {k: v for k, v in info.items() if k in keys and v}
    keys = (
        'Cmd', 'Entrypoint', 'Env', 'ExposedPorts',
        'Healthcheck', 'Labels', 'OnBuild', 'Shell',
        'StopSignal', 'User', 'Volumes', 'WorkingDir')
    if opts.verbose:
        data.update({k: v for k, v in info['config'].items() if k in keys and v})
    for key, value in sorted(data.items()):
        print("%-20s\t%s" % (key, value))
    if opts.verbose > 1:
        print_history(info['history'])


def print_fullinfox(reg, repo, tag="latest"):
    """
    Print full info about image
    """
    manifest_v1 = None
    fat_manifest = None

    # Get fat manifest
    if not tag.startswith("sha256:"):
        fat_manifest = reg.get_manifest(repo, tag, fat=True)
        if fat_manifest and 'manifests' in fat_manifest:
            print_fat_manifest(reg, repo, fat_manifest)
            return

    # Docker distribution may send a v1 when asked for a fat v2 that doesn't exist
    if fat_manifest and fat_manifest['schemaVersion'] == 1:
        manifest_v1 = fat_manifest

    # Single manifest
    manifest = reg.get_manifest(repo, tag)
    if not manifest:
        sys.exit(1)
    info = {}
    if not tag.startswith("sha256:"):
        if not manifest_v1:
            manifest_v1 = reg.get_manifest(repo, tag, version=1)
        if manifest_v1:
            info.update(get_infox(manifest_v1))
            info['created'] = pretty_date(info['created'])
    info['ID'] = manifest['docker-content-digest']
    info['Digest'] = manifest['config']['digest']
    info['CompressedSize'] = pretty_size(sum([_['size'] for _ in manifest['layers']]))
    for key, value in info.items():
        print("%-20s\t%s" % (key, value))
    if opts.verbose and manifest_v1:
        print_history(manifest_v1)


def print_history(history):
    """
    Print history
    """
    for i, item in enumerate(history):
        print(f"History[{i}]\t\t{item['created_by']}")


def print_historyx(manifest):
    """
    Print history
    """
    lines = [
        " ".join(json.loads(item['v1Compatibility'])['container_config']['Cmd'])
        for item in reversed(manifest['history'])]
    for i, line in enumerate(lines):
        print(f"History[{i}]\t\t{line}")


def print_info(reg, repo, tag, fmt):
    """
    Print full info about image
    """
    info = get_info(reg, repo, tag)
    if info is None:
        return
    docker_id = info['ID']
    if not opts.no_trunc:
        docker_id = docker_id[len("sha256:"):len("sha256:") + 12]
    print(fmt % (f"{repo} {tag}", info['Digest'], docker_id))


def get_images(reg, repos, pattern_tag=None):
    """
    Get images"
    """
    with ThreadPoolExecutor() as executor:
        yield from executor.map(lambda r: reg.get_tags(r, pattern_tag), repos)


def parse_opts():
    """
    Parse options and arguments
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-c', '--cert',
        help="Client certificate filename (may contain unencrypted key)")
    parser.add_argument(
        '-k', '--key',
        help="Client private key filename (unencrypted)")
    parser.add_argument(
        '-C', '--cacert',
        help="CA certificate for server")
    parser.add_argument(
        '--debug', action='store_true',
        help="Enable debug")
    parser.add_argument(
        '--insecure', action='store_true',
        help="Allow insecure server connections")
    parser.add_argument(
        '--no-trunc', action='store_true',
        help="Don't truncate output")
    parser.add_argument(
        '-u', '--username',
        help="Username for authentication")
    parser.add_argument(
        '-p', '--password',
        help="Password for authentication")
    parser.add_argument(
        '-v', '--verbose', action='count', default=0,
        help="Be verbose. May be specified multiple times")
    parser.add_argument('image')
    return parser.parse_args()


def main():
    """
    Main function
    """
    match = re.search(r'^((?:https?://)?[^:/]+(?::[0-9]+)?)/*(.*)', opts.image)
    registry, image = match.group(1), match.group(2)
    with DockerRegistry(
            registry,
            auth=(opts.username, opts.password) if opts.username else None,
            cert=(opts.cert, opts.key) if opts.cert and opts.key else opts.cert,
            headers={'User-Agent': "regview/" + __version__},
            verify=opts.cacert if opts.cacert else not opts.insecure,
            debug=opts.debug) as reg:
        glob_repo, glob_tag = None, None
        if '@' not in image and re.search(r"\*|\?|\[", image):
            glob_repo, glob_tag = image.split(':', 1) if ':' in image else (image, None)
        if image and not glob_repo:
            sep = '@' if '@' in image else ':'
            print_fullinfo(reg, *image.split(sep, 1))
            return
        repos = reg.get_repos(glob_repo)
        if not repos:
            sys.exit(1)
        # repo_width = max(len(repo) for repo in repos)
        image_width = int(get_terminal_size().columns / 2)
        fmt = "%-{}s %-72s %s".format(image_width)
        print(fmt % ("REPOSITORY TAG", "DIGEST", "ID"))
        for repo, tags in get_images(reg, repos, glob_tag):
            for tag in tags:
                print_info(reg, repo, tag, fmt)


if __name__ == "__main__":
    try:
        opts = parse_opts()
        main()
    except KeyboardInterrupt:
        sys.exit(1)
