#!/usr/bin/python3
"""
regview
"""

import argparse
import base64
import fnmatch
import json
import os
import re
import sys

from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from getpass import getpass
from shutil import get_terminal_size

import requests
from requests.exceptions import RequestException
from requests_toolbelt import GuessAuth
from requests_toolbelt.utils import dump
from urllib3 import disable_warnings


__version__ = "0.1.0a"


class DockerRegistry:
    """
    Class to implement Docker Registry methods
    """
    _supports_schema_v1 = None

    def __init__(self, registry, auth=None, cert=None, headers=None, verify=True, debug=False):  # pylint: disable=too-many-arguments
        self.session = requests.Session()
        if debug:
            self.session.hooks['response'].append(self._print_response)
        if auth is None:
            auth = self._get_creds(registry)
        elif auth[1] is None:
            auth = (auth[0], getpass("Password: "))
        self.session.auth = GuessAuth(*auth)
        self.session.cert = cert
        if headers is not None:
            self.session.headers.update(headers)
        self.session.verify = verify
        # Check if registry starts with a scheme and adjust accordingly
        if registry.startswith(("http://", "https://")):
            try:
                got = self.session.get(f"{registry}/v2/")
            except RequestException as err:
                sys.exit("%s" % err)
            self.registry = registry
        else:
            try:
                got = self.session.get(f"https://{registry}/v2/")
                self.registry = f"https://{registry}"
            except RequestException:
                try:
                    got = self.session.get(f"http://{registry}/v2/")
                    self.registry = f"http://{registry}"
                except RequestException as err:
                    sys.exit("%s" % err)
        if got.headers.get('docker-distribution-api-version') != 'registry/2.0':
            sys.exit(f"Invalid registry: {registry}")
        disable_warnings()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.session.close()

    @staticmethod
    def _get_creds(registry):
        """
        Gets the credentials from ~/.docker/config.json
        """
        config_file = os.path.join(
            os.getenv("DOCKER_CONFIG", os.path.expanduser(os.path.join("~", ".docker"))),
            "config.json")
        if not os.path.exists(config_file):
            return None
        with open(os.path.expanduser(config_file), "r") as file:
            config = json.load(file)
        try:
            auth = config['auths'][registry.replace("http://", "")]['auth']
            return tuple(base64.b64decode(auth).decode('utf-8').split(':', 1))
        except KeyError:
            pass
        return None

    @staticmethod
    def _print_response(got, *args, **kwargs):  # pylint: disable=unused-argument
        """
        Print response to aid in debugging
        """
        got.hook_called = True
        data = dump.dump_all(got)
        print(data.decode('utf-8'))
        return got

    def _get_paginated(self, url, string):
        """
        Get paginated results
        """
        items = []
        while True:
            got = self.session.get(url)
            if got.status_code != requests.codes.OK:  # pylint: disable=no-member
                print(f"ERROR: {url}: {got.reason}", file=sys.stderr)
                return None
            items.extend(got.json()[string])
            if 'Link' in got.headers:
                url = requests.utils.parse_header_links(got.headers['Link'])[0]['url']
                if url.startswith("/v2"):
                    url = f"{self.registry}{url}"
            else:
                break
        return items

    def get_repos(self, pattern=None):
        """
        Get repositories and return a dict of dicts with the repos as keys
        """
        repos = self._get_paginated(f"{self.registry}/v2/_catalog", "repositories")
        if repos and pattern:
            return fnmatch.filter(repos, pattern)
        return repos

    def get_tags(self, repo, pattern):
        """
        Get tags for specified repo
        """
        tags = self._get_paginated(f"{self.registry}/v2/{repo}/tags/list", "tags")
        if tags and pattern:
            tags = fnmatch.filter(tags, pattern)
        return repo, tags

    def get_manifest(self, repo, tag, version=2, ignore_errors=False):
        """
        Get the manifest
        """
        if version == 1 and self._supports_schema_v1 is False:
            return None
        url = f"{self.registry}/v2/{repo}/manifests/{tag}"
        content_type = f"application/vnd.docker.distribution.manifest.v{version}+json"
        got = self.session.get(url, headers={"Accept": content_type})
        if got.status_code != requests.codes.OK:  # pylint: disable=no-member
            if not ignore_errors:
                print(f"ERROR: {repo}:{tag}: {got.reason}", file=sys.stderr)
            return None
        manifest = got.json()
        if version == 1 and self._supports_schema_v1 is None:
            self._supports_schema_v1 = manifest['schemaVersion'] == 1
        elif version == 2:
            manifest['docker-content-digest'] = got.headers['docker-content-digest']
        return manifest


def get_info(manifest):
    """
    Get info from manifest schemaVersion 1
    """
    if manifest is None:
        return None
    data = json.loads(manifest['history'][0]['v1Compatibility'])
    keys = ('architecture', 'created', 'docker_version', 'os')
    info = {key: data[key] for key in keys}
    keys = (
        'Cmd', 'Entrypoint', 'Env', 'ExposedPorts',
        'Healthcheck', 'Labels', 'OnBuild', 'Shell',
        'StopSignal', 'User', 'Volumes', 'WorkingDir'
    )
    info.update({key: data['config'].get(key, "") for key in keys})
    return info


def pretty_size(size):
    """
    Converts a size in bytes to a string in KB, MB, GB or TB
    """
    units = (' ', 'K', 'M', 'G', 'T')
    for i in range(4, -1, -1):
        if size > 1024**i:
            return "%.2f%cB" % (float(size) / 1024**i, units[i])
    return None


def pretty_date(string):
    """
    Converts date/time string in ISO-8601 format to date(1)
    """
    utc_date = datetime.fromisoformat(re.sub(r"\.\d+Z$", "+00:00", string))
    return utc_date.astimezone().strftime("%a %b %d %H:%M:%S %Z %Y")


def print_fullinfo(reg, image):
    """
    Print full info about image
    """
    try:
        repo, tag = image.split(':', 1)
    except ValueError:
        repo, tag = image, "latest"
    manifest = reg.get_manifest(repo, tag)
    if manifest is None:
        sys.exit(1)
    info = {}
    if not tag.startswith("sha256:"):
        manifest_v1 = reg.get_manifest(repo, tag, version=1, ignore_errors=True)
        if manifest_v1:
            info.update(get_info(manifest_v1))
            info['created'] = pretty_date(info['created'])
    info['ID'] = manifest['docker-content-digest']
    info['Digest'] = manifest['config']['digest']
    info['CompressedSize'] = pretty_size(sum([_['size'] for _ in manifest['layers']]))
    for key, value in info.items():
        if not value:
            continue
        print("%-20s\t%s" % (key, value))


def print_info(reg, repo, tag, fmt):
    """
    Print full info about image
    """
    manifest = reg.get_manifest(repo, tag)
    if manifest is None:
        return
    # info = get_info(reg.get_manifest(repo, tag, version=1))
    docker_id, digest = manifest['config']['digest'], manifest['docker-content-digest']
    if not opts.no_trunc:
        docker_id = docker_id[len("sha256:"):-52]
    print(fmt % (f"{repo} {tag}", digest, docker_id))


def get_images(reg, repos, pattern_tag=None):
    """
    Get images"
    """
    with ThreadPoolExecutor() as executor:
        yield from executor.map(lambda r: reg.get_tags(r, pattern_tag), repos)


def parse_opts():
    """
    Parse options and arguments
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-c', '--cert',
        help="Client certificate filename (may contain unencrypted key)")
    parser.add_argument(
        '-k', '--key',
        help="Client private key filename (unencrypted)")
    parser.add_argument(
        '-C', '--ca-cert',
        help="CA certificate for server")
    parser.add_argument(
        '--debug', action='store_true',
        help="Enable debug")
    parser.add_argument(
        '--insecure', action='store_true',
        help="Allow insecure server connections")
    parser.add_argument(
        '--no-trunc', action='store_true',
        help="Don't truncate output")
    parser.add_argument(
        '-u', '--username',
        help="Username for authentication")
    parser.add_argument(
        '-p', '--password',
        help="Password for authentication")
    parser.add_argument('image')
    return parser.parse_args()


def main():
    """
    Main function
    """
    match = re.search(r'^((?:https?://)?[^:/]+(?::[0-9]+)?)/*(.*)', opts.image)
    registry, image = match.group(1), match.group(2)
    with DockerRegistry(
            registry,
            auth=(opts.username, opts.password) if opts.username else None,
            cert=(opts.cert, opts.key) if opts.cert and opts.key else opts.cert,
            headers={'User-Agent': "regview/" + __version__},
            verify=opts.ca_cert if opts.ca_cert else not opts.insecure,
            debug=opts.debug) as reg:
        glob_repo, glob_tag = None, None
        if re.search(r"\*|\?|\[", image):
            if ':' in image:
                glob_repo, glob_tag = image.split(':', 1)
            else:
                glob_repo = image
        if image and not glob_repo:
            print_fullinfo(reg, image)
            return
        repos = reg.get_repos(glob_repo)
        # repo_width = max(len(repo) for repo in repos)
        image_width = int(get_terminal_size().columns / 2)
        fmt = "%-{}s %-72s %s".format(image_width)
        print(fmt % ("REPOSITORY TAG", "DIGEST", "ID"))
        for repo, tags in get_images(reg, repos, glob_tag):
            for tag in tags:
                print_info(reg, repo, tag, fmt)


if __name__ == "__main__":
    try:
        opts = parse_opts()
        main()
    except KeyboardInterrupt:
        sys.exit(1)
